+++
title = "一致性哈希"
date = "2020-09-18"
tags = [ "数据结构" ]
categories = [ "others" ]
+++

**一致性哈希** 是一种特殊的`hash`算法(散列)。在`HashTable`(`HashMap`)等槽位扩容或缩容的时候，只需对平均`K/n`个关键字进行映射，其中**K**是关键字的数量，*n*是槽位数量。
<!--more-->

### hash实现(非对称加密)
`hash`算法的主要实现有`MD5`,`SHA`:
1. MD5(128位，是一种checksum校验和的算法)
2. SHA-224、SHA-256、SHA-384、SHA-512

### 自定义hash函数
当为类型设计`hash code`算法的时候，请遵循以下实践：
1. 使用一种能够提供良好随机分布的算法，使得`HashTable`能获得最佳性能。
2. 调用基类的`GetHashCode`方法，并包含它的返回值。但是不要调用`Object`或`ValueType`的`GetHashCode`方法，因为
这两种性能都不高效。
3. 算法至少使用一个实例字段(`field`)。
4. 理想情况下，算法中使用的字段在构造函数中初始化，并且在对象生命周期中应该是不可变的。
5. 算法应该高效。
6. 具有相同值的对象应返回相同的**HashCode**。例如，两个字符串对象使用相同的文本应该返回相同的**HashCode**。

> 不要持久化`GetHashCode()`方法生成的**HashCode**到数据库。因为随着版本的升级，算法会发生变化，造成意想不到的结果。

Java编程思想提供了生成均匀分布的`HashCode`的基本方法：
1. 在一个名为result的int变量中存储一些常量非零值，比如17。
2. 为对象中的每个不变字段，计算出一个`int`型的hash code **c**。
|Field Type|Calculation|
|:-:|:-:|
|boolean|c = (f?0:1)|
|byte,char,short,int|c = (int)f|
|long|c = (int)(f^(f\>\>\>32))|
|float|c = Float.floatToIntBits(f);|
|double|long l = Double.doubleToLongBits(f);c = (int)(1 ^ (l\>\>\>32));|
|Object|c = f.hashCode()|
|Array|Apply above rules to each element|
3. 累加上面计算的哈希码:`result = 37 * result + c;`
4. `return result;`
5. 测试以确保相同的实例有相同的hash code。
> 确保均匀分布，使用primes(素数)做因子：例如37与17

#### c#实现`GetHashCode()`方法
```c#

```


